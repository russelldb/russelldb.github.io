<!DOCTYPE html>  
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>2.dvv</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
/*
   This document has been created with Marked.app <http://markedapp.com>, Copyright 2011 Brett Terpstra
   Please leave this notice in place, along with any additional credits below.
   ---------------------------------------------------------------
   Title: Swiss
   Author: Brett Terpstra
   Description: Clean, Swiss typography with no frills.
*/
body{-webkit-font-smoothing:antialiased;font:normal .8764em/1.5em Arial,Verdana,sans-serif;margin:0}html>body{font-size:13px}li{font-size:110%}li li{font-size:100%}li p{font-size:100%;margin:.5em 0}h1{color:#000;font-size:2.2857em;line-height:.6563em;margin:.6563em 0}h2{color:#111;font-size:1.7143em;line-height:.875em;margin:.875em 0}h3{color:#111;font-size:1.5em;line-height:1em;margin:1em 0}h4{color:#111;font-size:1.2857em;line-height:1.1667em;margin:1.1667em 0}h5{color:#111;font-size:1.15em;line-height:1.3em;margin:1.3em 0}h6{font-size:1em;line-height:1.5em;margin:1.5em 0}body,p,td,div{color:#111;font-family:"Helvetica Neue",Helvetica,Arial,Verdana,sans-serif;word-wrap:break-word}h1,h2,h3,h4,h5,h6{line-height:1.5em}a{-webkit-transition:color .2s ease-in-out;color:#0d6ea1;text-decoration:none}a:hover{color:#3593d9}.footnote{color:#0d6ea1;font-size:.8em;vertical-align:super}#wrapper img{max-width:100%;height:auto}dd{margin-bottom:1em}li>p:first-child{margin:0}ul ul,ul ol{margin-bottom:.4em}caption,col,colgroup,table,tbody,td,tfoot,th,thead,tr{border-spacing:0}table{border:1px solid rgba(0,0,0,0.25);border-collapse:collapse;display:table;empty-cells:hide;margin:-1px 0 23px;padding:0;table-layout:fixed}caption{display:table-caption;font-weight:700}col{display:table-column}colgroup{display:table-column-group}tbody{display:table-row-group}tfoot{display:table-footer-group}thead{display:table-header-group}td,th{display:table-cell}tr{display:table-row}table th,table td{font-size:1.1em;line-height:23px;padding:0 1em}table thead{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-bottom:1px solid rgba(0,0,0,0.2)}table tbody{background:rgba(0,0,0,0.05)}table tfoot{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-top:1px solid rgba(0,0,0,0.2)}figure{display:inline-block;margin-bottom:1.2em;position:relative;margin:1em 0}figcaption{font-style:italic;text-align:center;background:rgba(0,0,0,.9);color:rgba(255,255,255,1);position:absolute;left:0;bottom:-24px;width:98%;padding:1%;-webkit-transition:all .2s ease-in-out}.poetry pre{display:block;font-family:Georgia,Garamond,serif!important;font-size:110%!important;font-style:italic;line-height:1.6em;margin-left:1em}.poetry pre code{font-family:Georgia,Garamond,serif!important}blockquote p{font-size:110%;font-style:italic;line-height:1.6em}sup,sub,a.footnote{font-size:1.4ex;height:0;line-height:1;position:relative;vertical-align:super}sub{vertical-align:sub;top:-1px}p,h5{font-size:1.1429em;line-height:1.3125em;margin:1.3125em 0}dt,th{font-weight:700}table tr:nth-child(odd),table th:nth-child(odd),table td:nth-child(odd){background:rgba(255,255,255,0.06)}table tr:nth-child(even),table td:nth-child(even){background:rgba(0,0,0,0.06)}@media print{body{overflow:auto}img,pre,blockquote,table,figure,p{page-break-inside:avoid}#wrapper{background:#fff;color:#303030;font-size:85%;padding:10px;position:relative;text-indent:0}}@media screen{.inverted #wrapper,.inverted{background:rgba(37,42,42,1)}.inverted hr{border-color:rgba(51,63,64,1)!important}.inverted p,.inverted td,.inverted li,.inverted h1,.inverted h2,.inverted h3,.inverted h4,.inverted h5,.inverted h6,.inverted th,.inverted .math,.inverted caption,.inverted dd,.inverted dt{color:#eee!important}.inverted table tr:nth-child(odd),.inverted table th:nth-child(odd),.inverted table td:nth-child(odd){background:0}.inverted pre code{color:#111}.inverted a{color:rgba(172,209,213,1)}#wrapper{padding:20px}::selection{background:rgba(157,193,200,.5)}h1::selection{background-color:rgba(45,156,208,.3)}h2::selection{background-color:rgba(90,182,224,.3)}h3::selection,h4::selection,h5::selection,h6::selection,li::selection,ol::selection{background-color:rgba(133,201,232,.3)}code::selection{background-color:rgba(0,0,0,.7);color:#eee}code span::selection{background-color:rgba(0,0,0,.7)!important;color:#eee!important}a::selection{background-color:rgba(255,230,102,.2)}.inverted a::selection{background-color:rgba(255,230,102,.6)}td::selection,th::selection,caption::selection{background-color:rgba(180,237,95,.5)}}
</style>

</head>
<body class="normal">
  <div id="wrapper">
      <h1 id="dottedversionvectorsinriak">Dotted Version Vectors In Riak</h1>

<p><a href="http://basho.com/posts/technical/vector-clocks-revisited/">Last time</a>
I wrote about vnode version vectors, and how they simplify client
interaction with Riak, while keeping logical clock sizes small. I also
mentioned a bug: &#8220;sibling explosion.&#8221; This post is going to describe
that bug, and the fix for it: Dotted Version Vectors.</p>

<p>There is a lot of other material about Dotted Version Vectors out
there, including
<a href="https://www.youtube.com/watch?v=3SWSw3mKApM">Sean Cribbs&#8217; Talk</a>, an
excellent
<a href="https://github.com/ricardobcl/Dotted-Version-Vectors">Github repo and README</a>
from
<a href="http://gsd.di.uminho.pt/members/tome.html">Ricardo Tomé Gonçalves</a>,
and a paper
<a href="http://arxiv.org/abs/1011.5808">Dotted Version Vectors: Logical Clocks for Optimistic Replication</a>. This
blog post covers only the application of Dotted Version Vectors in
Riak.</p>

<h2 id="vnodeversionvectorrecap">Vnode Version Vector Recap</h2>

<p>In the last post we saw how Vnode version vectors tweak the standard
version vector algorithm. Let&#8217;s quickly recap how.</p>

<p>With a <em>ClientId Version Vector</em> Riak generated siblings like this:</p>

<ol>
<li>If Local Version Vector <em>descends</em> Incoming

<ol>
<li>Discard/ignore incoming write</li>
</ol></li>
<li>If Incoming <em>descends</em> Local

<ol>
<li>Write new value to disk</li>
</ol></li>
<li>If Incoming <em>concurrent</em> with Local

<ol>
<li><em>Merge</em> Incoming and Local Version Vectors</li>
<li>Store Incoming value as a <em>sibling</em></li>
</ol></li>
</ol>

<p>But with Vnode Version Vectors this becomes:</p>

<ol>
<li>If Local Version Vector <em>descends</em> Incoming

<ol>
<li>Increment Vnode&#8217;s entry in <em>local</em> Version Vector</li>
<li>Store Incoming value as a <em>sibling</em></li>
</ol></li>
<li>If Incoming <em>descends</em> Local

<ol>
<li>Increment Vnode&#8217;s entry in <em>incoming</em> Version Vector</li>
<li>Write new value to disk</li>
</ol></li>
<li>If Incoming <em>concurrent</em> with Local

<ol>
<li><em>Merge</em> Incoming and Local Version Vectors</li>
<li>Increment Vnode&#8217;s entry in <em>merged</em> Version Vector</li>
<li>Store Incoming value as a <em>sibling</em></li>
</ol></li>
</ol>

<p>We use a single version vector to cover the full set of sibling
values. But a version vector is not enough to correctly track
causality when the actor, the vnode, is a proxy for multiple clients.</p>

<h2 id="siblingexplosion">Sibling Explosion</h2>

<p>What is Sibling Explosion, and how does it happen?</p>

<p>Imagine two clients <code>X</code>, and <code>Y</code>. They&#8217;re both updating the same
key. For simplicity this illustration will use Riak&#8217;s <code>Return Body</code>
option, which means Riak replies to every <code>PUT</code> with the latest result
it stored on disk at the coordinating vnode. This is just simpler than
having the client fetch after every <code>PUT</code>.</p>

<figure>
<img src="sib-ex.png" alt="Interleaved Writes: Sibling Explosion" title="Interleaved Writes: Sibling Explosion" />
<figcaption>Interleaved Writes: Sibling Explosion</figcaption></figure>



<p>In the above diagram we see a &#8220;sibling explosion.&#8221; Vnode Version
Vectors are incapable of tracking causality in a fine grained manner,
and these interleaving writes generate <em>false concurrency</em>. Let&#8217;s walk
through the steps as numbered on the diagram.</p>

<ol>
<li><p>Client Y PUTs the value &#8220;Bob&#8221; with an empty context.</p></li>
<li><p>Vnode A sees that <code>[]</code> <em>descends</em> the local Version Vector (also
 <code>[]</code>) and increments its entry in the incoming Version Vector,
 storing the value with new version Vector <code>[{a, 1}]</code>. The value
 <code>&quot;Bob&quot;</code> and context <code>[{a, 1}]</code> are returned to Client Y.</p></li>
<li><p>Client X PUTs the value &#8220;Sue&#8221; with an empty context. This PUT is
 causally concurrent with Client Y&#8217;s at Step 1.</p></li>
<li><p>Using the algorithm described above, Vnode A detects that the
 context <code>[]</code> does not <em>descend</em> <code>[{a, 1}]</code> and treats the write as
 concurrent, it increments the local Version Vector to <code>[{a, 2}]</code>
 and stores the incoming value as a <code>sibling</code>. So far so good. The
 Vnode Version Vector correctly captured concurrency! Vnode A
 returns the sibling values <code>[&quot;Bob&quot;, &quot;Sue&quot;] [{a, 2}]</code> to Client X.</p></li>
<li><p>Client Y PUTs the value &#8220;Rita&#8221; with the context
 <code>[{a, 1}]</code>. Remember that Client Y saw the result of its own PUT
 before Client X PUT at step 3.</p></li>
<li><p>Vnode A detects that the incoming Version Vector <code>[{a, 1}]</code> does
 not <em>descend</em> the local Version Vector of <code>[{a, 2}]</code>. It increments
 its entry in the local Version Vector, and adds &#8220;Rita&#8221; as a sibling
 value. Wait! What? We <em>know</em> that Client Y <em>saw</em> &#8220;Bob&#8221; as a value,
 after all, it PUT that value! So &#8220;Rita&#8221; should at least <em>replace</em>
 &#8220;Bob&#8221;. Yes, it is concurrent with &#8220;Sue&#8221;, but only &#8220;Sue&#8221;.</p></li>
<li><p>Client X PUTs a new value &#8220;Michelle&#8221; with context
 <code>[{a, 2}]</code>. Client Y means to replace what it has read, the sibling
 values &#8220;Bob&#8221; and &#8220;Sue&#8221; with a new, single value &#8220;Michelle&#8221;.</p></li>
<li><p>As before Vnode A detects that <code>[{a, 2}]</code> does not <em>descend</em>
 <code>[{a, 3}]</code> and adds the incoming value as a sibling. Again, we can
 see this is wrong. At Step 4 Client X saw both &#8220;Bob&#8221; and &#8220;Sue&#8221; and
 this new write intends to replace those values.</p></li>
</ol>

<h3 id="whatjusthappened">What Just Happened?</h3>

<p>Vnode A loses some essential causal information. At Step 4 it ends up
storing both &#8220;Bob&#8221; and &#8220;Sue&#8221; with a Version Vector of <code>[{a, 2}]</code>. It
has &#8220;forgotten&#8221; that &#8220;Bob&#8221; was associated with time <code>[{a, 1}]</code>. When
Client Y PUTs again, with the now stale context of <code>[{a,1}]</code> the Vnode
is unable to determine that this PUT means to replace &#8220;Bob&#8221; since
&#8220;Bob&#8221; is now associated with the version vector <code>[{a, 2}]</code>.</p>

<h2 id="dotstotherescue">Dots To The Rescue</h2>

<p>What we need is a fine grained mechanism to detect which siblings are
removed by an update, and which siblings are actually concurrent or
unrelated causally. That mechanism is the &#8220;dot&#8221;. Recall the basics of
a Version Vector: that each actor must update its own entry in the
vector by incrementing a counter. This counter is a summary of all the
actors events. An entry <code>{a, 4}</code> says that actor <code>a</code> has issued 4
updates. Integers make great summaries. 4 includes 1, 2, 3, 4. Each of
those steps that the counter went through is an update. And that is
all a dot is: a single update, an event. Take the update <code>{a,
4}</code>. That is an event, an update, a dot. You can think of the Version
Vector entry <code>{a, 4}</code> as a set of discrete events, and a dot as any
one of those events.</p>

<figure>
<img src="dots-vv.png" alt="Dots are just events" title="Dots are just events" />
<figcaption>Dots are just events</figcaption></figure>



<p>Hopefully the diagram above illustrates this. It&#8217;s two different
visual representations of the same Version Vector
<code>[{A, 4}, {B, 2}, {C, 3}]</code>. The one on the right is a type of
visualization I first saw when working with a group of academics from
University Minho, and it helps illustrate the idea of Version Vectors
and the history they summarize. The one on the left &#8220;explodes&#8221; the
version vector into its discrete events.</p>

<h2 id="dottheclocks">Dot The clocks</h2>

<p>How does this help with the problem described above? We change the
algorithm again. When we increment the version vector to store a new
value, we take that latest event and store it, as a dot, with the
value.</p>

<pre><code>[&quot;Bob&quot;, &quot;Sue&quot;] [{a, 2}]
</code></pre>

<p>Becomes</p>

<pre><code>[{a,1} -&gt; &quot;Bob&quot;,
 {a, 2} -&gt; &quot;Sue&quot;] [{a, 2}]
</code></pre>

<p>That&#8217;s all we have to do add fine grained causality tracking. Now when
we have interleaving writes as above, we can see which sibling values
an update replaces, and which it does not, by comparing the incoming
version vector with the dots for each value. If the version vector
<em>descends</em> the dot, the client has seen that value and the new write
supersedes it. If the version vector is concurrent with the dot,
retain that value as a truly concurrent write, or sibling.</p>

<figure>
<img src="dvv-update.png" alt="DVV Update" title="DVV Update" />
<figcaption>DVV Update</figcaption></figure>



<p>This diagram shows Step 6 again, this time with Dotted Version
Vectors. We can see that the extra Meta data, the Dot stored with a
value, enables Riak to discard the value &#8220;Bob&#8221; since the incoming
Version Vector of <code>[{a, 1}]</code> <em>descends</em> the dot stored with that
value. The new dot generated from this update event <code>{a, 3}</code> is used
to tag the new sibling &#8220;Rita&#8221;. &#8220;Sue&#8221; remains as a <em>genuine sibling</em>,
since it is unseen by the incoming Version Vector <code>[{a, 1}]</code> we know
that Client Y did not mean to replace that value.</p>

<p>Thanks to this mechanism, Dotted Version Vectors, or <em>DVV</em> for short,
a small increase in meta data storage fixes the Sibling Explosion bug.</p>

<h3 id="whydots">Why &#8220;Dots?&#8221;</h3>

<p>Why that word &#8220;Dots?&#8221; If we think about Step 6 again, in the Dotted
Version Vector case, you can imagine Vnode A generating the event <code>{a,
3}</code> and assigning it to the incoming value at once. Then merging the
incoming DVV with the local one. The visualization of that PUT with
dot assigned hopefully explains the name.</p>

<figure>
<img src="dotted-ctx.png" alt="Context of {a, 1} with a Dot of {a,3}" title="Context of [{a,1}] and a dot of {a, 3}" />
<figcaption>Context of {a, 1} with a Dot of {a,3}</figcaption></figure>



<p>Conceptually there is gap between the incoming version vector
<code>[{a, 1}]</code> and the event <code>{a, 3}</code>, and this gap leads to naming the
non-contiguous event a Dot. Like the dot on a lower case letter
&#8220;i&#8221;. Strictly speaking a &#8220;dot&#8221; is a non-contiguous event, but they&#8217;re
used in other places (like CRDTs) simply as discrete event tags, so
the simpler explanation is good enough.</p>

<h2 id="furthermaterial">Further Material</h2>

<p>This post only covers how Dotted Version Vectors are implemented in
Riak. By necessity we simply added the dot-per-sibling to object
meta data. Dotted Version Vectors in Riak are fully backwards
compatible with previous versions of Riak, and they can be switched on
or off with a simple bucket property. Since Riak 2.0 Dotted Version
Vectors are the default logical clock for bucket types in
Riak. However, there are other implementations out there. Ricardo Tomé
Gonçalves implemented an optimized Dotted Version Vector, called a
Dotted Version Vector Set. The git repository is
<a href="https://github.com/ricardobcl/Dotted-Version-Vectors">here</a>, and his
code is also currently used in Riak for tracking Cluster Meta Data.</p>

<p>If you use Riak you get to use <em>DVV</em> for free, and you need never know
nor care about the details. From a client perspective it is the same
as Vnode Version Vectors, minus of course the sibling explosions.</p>

<p>If you want to use Dotted Version Vectors in your own distributed
application, then I recommend you read the
<a href="http://arxiv.org/abs/1011.5808">paper</a>, and Ricardo Tomé Gonçalves
<a href="https://github.com/ricardobcl/Dotted-Version-Vectors">repo</a>.</p>

<h2 id="withthanks">With thanks</h2>

<p>For the sake of brevity this post does not tell the story of how we at
Basho Engineering came to have Dotted Version Vectors in Riak. In
short, some very brilliant academics in Portugal came up with Dotted
Version Vectors as a solution to sibling explosion and then let us
have it. This is the wonderful thing about research science, and I&#8217;m
extremely grateful to have had the chance to work with Nuno Pregucia,
Carlos Baquero, Paulo Almeida, Ricardo Goncalves, Valter Balegas, and
others while fixing sibling explosion in Riak. The story of Sibling
Explosion and Dotted Version Vectors in Riak truly is an example of
academic expertise solving real world, industrial problems. Thanks
again!</p>

<h2 id="summary">Summary</h2>

<p>Thanks to Vnode Version Vectors client interaction with Riak is
simple, Read Your Own Writes is not required, and Version Vectors
remain small. Thanks to Dotted Version Vectors we get to keep all
those benefits without the risk of large objects from Sibling
Explosion.</p>

<h2 id="nexttimeonlogicalclocks">Next Time on Logical Clocks</h2>

<p>In the next post we look at another, less common bug that can lead to
the past looking like the future.</p>
    </div>
</body>
</html>